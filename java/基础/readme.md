day1 
###java 通过虚拟机实现跨平台(一次编译,到处运行)
	编译成class,通过java虚拟机在操作系统上运行
###jre与jdk
	jre java运行环境.  jre = java虚拟机+核心类库(java虚拟机运行的文件)
	jdk	 java开发工具集	 jdk = jre+java开发工具
	
	java.exe 启动java虚拟机编译并执行指定的class文件
	javac.exe 启动java编译器对指定的java源文件进行编译
###配置path环境的目的
		控制台可以在任意的路径下找到java开发工具
###main方法:
	程序的主入口,代码是从住方法上开始执行的.
	定义一个类中使用,如果一个类需要独立运行的时候,就需要main方法.
###注释
		单行注释:  //注释内容
		多行注释:  /*注释内容*/
		文档注释:  /***注释内容*/
	文档注释与多行注释的区别:
		多行注释的内容不能用于生成一个开发者文档,而文档注释的内容可以生产一个开发者文档.
	单行注释可以嵌套,多行注释和文档注释不能嵌套.
###使用javadoc工具  javadoc -d 位置 源文件名.java
	1.如果一个类需要使用javadoc工具生成一个软件的开发者文档,那么该类必须使用public修饰.
	2.文档注释注释的内容一般都是位于类或者方法的上面
####常量:	
		整数常量
			二进制用0b开头
			八进制用0开头
			十六进制用0x开头
		小数常量
		布尔常量
		字符常量
		字符串常量
####变量数据类型
	基本数据类型:8种类型
		整数的数据类型:
			byte(字节)   8位(bit)   2*8=256	-128~127
			short(短整型)	16bit
			int(整型)		32bit   
			long(长整型)	64bit
				注意:如果用long类型的数据,数据后需要加L标识
		小数的数据类型:
			float(单精度浮点型)		32bit
			double(双精度浮点型)	64bit
				注意:如果一个小数没有加上任何标识的时候,那么该小数默认是double类型的数据,
					如果需要用float,数据后面需要加f标识
		布尔类型:
			boolean:只有true或者false	1个字节或4个字节
			注意:如果使用boolean声明一个基本类型的变量时,那么该变量占4个字节,如果声明一个数组类型时,那么每个数组的元素占一个字节.
		字符类型:
			char   'a' 单引号是字符.   "a"双引号是字符串
	数据类型转换注意:
		1.凡是byte,short,char数据在运算的时候都会自动转换为int类型的数据再运算.
		2.两个不同数据类型的数据在运算的时候,结果取决于大的数据类型
		3.java编译器在编译的时候并不能确认变量所存储的值,变量存储的值是在运行的时候才在内存中分配空间.
	引用数据类型:
		字符串的数据类型
			String
			注意:字符串属于引用数据类型,不属于基本数据类型
		注意:"=="用于引用类型变量时,比较的是内存地址.
			 如果比较两个字符串的内容是否一致,使用equals方法.
###运算符
####算数运算符
	+	注意:任何类型的数据与字符串使用+连接,那么结果都是字符串类型的数据.
	%  取模,取余数 注意:java中取模运算时,结果的正负号取决于被除数
	++ (自增):  操作数+1 
		前自增(++a): 先自增,后使用.
		后自增(a++):  先使用,后自增.
####逻辑运算符
	&(与)
	|(或)
	^(异或)  两边不一致则为true,一致则为false
	!(非)
	&&(短路与|双与)	
		与&不同点: 使用短路与的时候,如果左边的布尔表达式为false,则不会再运算右边的布尔表达式 .
			在左侧为false的情况下,&&效率要高于&
	||(短路或)	
		与|不同点:	使用短路或的时候,当发现左边的布尔表达式为true时,则不会运算右边的布尔表达式.
####位运算符
	&(与)	6&2=2 转为二进制,进行与运算,得到结果后转为十进制
	|(或)	
	^(异或)
	规律:如果操作数A连续异或同一个操作数两次,那么结果还是操作数A
	应用:对数据进行加密
	~(取反)
####移位运算符
	<<(左移)	左移n位,等于操作数乘以2的n次方.
	>>(右移)	
	>>>(无符号右移)
		与右移的区别:进行右移运算的时候,如果操作数是一个整数,那么左边的空缺位使用0补,
		如果操作数是一个负数,那么左边的空缺位使用1补.而使用无符号右移的均用0补.
####三元运算符
	格式:布尔表达式?值1:值2;
###语句
####if判断语句
	细节:如果符合条件后只有一句代码需要执行,那么可以省略大括号.
####switch选择语句
		格式:
			switch(option){
				case 1:
					break;
				case 2:
					break;
				default: 
					break;
				}
	1.case后面跟的数据必须是一个常量.
	2.switch的停止条件:
		witch语句一旦匹配上了其中的一个case语句,那么就会执行对应的case中的语句代码,
		执行完毕后如果没有遇到break或者结束switch语句的大括号,那么switch语句不会再
		判断,而是按照代码的顺序从上往下执行所有的代码.
	3.都不符合条件,则执行default语句.
####while与do while的区别:
	while 会先判断再执行.
	do while 会先执行再判断,所以不管条件是否满足至少会执行一次
####转义字符 
	特殊字符使用"\"将其转化成字符的本身输出,那么使用"\"的字符 作为转义字符
	常见的转义字符:
		\b 退格键
		\t Tab键盘(为了让一列对齐,一个tab一般等于4个空格)
		\n 换行
		\r 回车(把光标移动到一行的首位置上)
	注意:如果是在windows系统上操作文件的时候需要换行,需要\r\n一起使用的.
		 如果是其他的操作系统上需要换行,仅需要\n即可
####break作用于外层的for循环:
	通过对循环进行标记,然后break 标记.
	实例:
		outer:for(int a=0;a<3;a++){
			inner:for(int b=0;b<2;b++}{
				break outer;}
				}
###函数
####定义函数
	格式:
		修饰符 返回值类型 函数名(形参列表){
			代码}
####函数的重载
	定义:在一个类中出现两个或者两个以上的同名函数,成为函数的重载
	作用:同一个函数名可以出现了不同的函数,以应对不同个数或者不同数据类型的参数.
####变量种类:
	局部变量:如果一个变量时在一个方法的内部生命的,那么该变量就是一个局部变量.
	成员变量:成员变量就是定义在方法之外,类之内的.
####内存种类:
	栈内存特点:栈内存存储的都是局部变量,变量一旦出了自己的作用于,那么马上会从内存中消失,释放内存空间
		
	堆内存特点:堆内存存储的都是对象数据(除8种基本数据类型以外的数据类型),对象一旦被使用完,并不会马上从内存中小时,而是等待垃圾回收期不定时
				把对象回收,这时候该对象才会消失,释放内存.
		对象如果没有变量引用了,那么该对象就是一个垃圾对象.
		凡是以new关键字创建的对象,jvm都会在堆内存中开辟一个新的空间,创建一个新的对象.
	
###数组
	一维数组定义格式: 
		数据类型[] 变量名 = new 数据类型[长度]
	二维数组定义格式:
		数据类型[][] 变量名 = new 数组类型[长度1][长度2]
	数组中元素与元素之间的内存地址是连续的
	初始化方式:
		动态初始化:
			数据类型 变量名 = new 数据类型[长度]
		静态初始化:
			数据类型[] 变量名 = {元素1,元素2....}
	数组方法:
		需要导入java.util.Arrays
		1.Array.toString(数组名) 数组转字符串
		2.Array.sort(数组名)	(选择排序算法)排序数组
		3.Arrays.binarySearch(数组名.目标值)	(二分法查找)查找数值.如果能找到对应的元素,返回索引值,如果没有找到那么返回一个负数表示.

##面向对象
####面向对象的三大特征:封装,继承,多态
####自定义类创建对象的三步骤:
		1.自定义类:
				格式:
					class 类名{
						}
		2.通过自定义类创建对象 .
				格式:
					类名 变量名 = new 类名()
		3.访问(设置)对象的属性或者调用对象的功能.
			访问对象属性的格式:
				对象.属性名.
			设置对象的属性:
				对象.属性名 = 数据
###封装
	步骤:
	1.使用private属性
	2.提供一个公共的方法设置或者获取私有的成员属性.
			命名规范:
				set属性名();
				get属性名();
	规范:在现实开发中一般实体类的所有成员属性(成员变量)都要封装.
	实体类:用于描述一类事物的
	工具类(array数组的工具类)
	封装的好处:
		1.提高数据的安全性.
		2.操作简单.
		3.隐藏了实现
	
#####权限修饰符:控制变量的可见范围.
	public:公共的.均可访问.
	private:私有的.只能在本类中直接访问,
	protected:受保护的,可以在本类和子类访问
	
####成员变量与局部变量的区别:
	class Person{
		String name;//成员变量
		public void eat(){
			String name;//局部变量
		}
	}
	1.定义位置的区别:
		成员变量:定义在方法之外,类之内.
		局部变量:定义在方法之内.
	2.作用上的区别:
		成员变量:用于描述一类事物的公共属性.
		局部变量:提供一各变量给方法内部使用而已/
	3.生命周期的区别:
		1.成员变量:随着对象的创建而存在,随着对象的消失而消失.
		2.局部变量:在调用对应的方法时执行到了创建该变量的语句时存在,局部变量一旦出了自己的作用域,那么马上从内存中消失.
	4.初始值的区别:
		1.成员变量是有默认的初始值.
			例如:
				String = null
				int = 0
				char = ' '
		2.局部变量没有默认的初始值,必须要先初始化才能使用.

####匿名对象:没有引用类型变量指向的对象
	格式:
		new 类型()
	注意事项:
		1.一般不会给匿名对象赋予属性值,因为永远无法获取到.
		2.两个匿名对象永远都不可能是同一个对象.
	应用场景:
		1.如果一个对象需要调用一个方法,而调用完这个方法之后,不再使用该对象.
		2.作为实参调用一个参数
		
####构造函数:
	作用:给对应的对象进行初始化.
	格式:
		修饰符	函数名(形参函数){
			函数体...
		}
	构造函数要注意的细节:
		1.没有返回值类型.
		2.函数名必须要与类名一致.
		3.构造函数会在创建对应的对象时,jvm会主动调用到对应的构造函数
		4.如果一个类中如果没有显式的协商一个构造方法时,java编译器会为该类添加一个无参的构造函数.
	构造代码块:
		作用:给对象进行统一的初始化.
		格式:
			{
				构造代码块
			}
		注意:构造代码块的大括号必须位于成员位置上.
		类别:
			1.构造代码块.
			2.局部代码块.	大括号位于方法之内.作用:缩短局部变量的生命周期,节省内存
	注意事项:
		1.java编译器编译一个java源文件的时候,会把成员变量的声明语句提前至一个类的最前端.
		2.成员变量的初始化工作其实都在构造函数中执行的.
		3.一旦经过javav编译器编译后,那么构造代码块的代码块就会被移动构造函数中执行,构造函数中的代码是最后执行的.
		4.成员变量的显示初始化与构造代码块的代码是按当前顺序执行的

####this
	一个方法要运行的时候,jvm会在栈内存中开辟一片属于这个方法的空间,在空间中运行.
	解决问题: 存在同名的成员变量与局部变量时,在方法的内部访问的是局部变量(java采取"就近原则"机制访问的)
	作用:
		1.如果存在同名成员变量或局部变量.
		2.在一个构造函数中可以调用另外一个构造函数初始化对象. this();
	注意事项:
		1.this关键字调用其他的构造函数时,this关键字必须要位于构造函数中的第一个语句.
		2.this关键字在构造函数中不能出现相互调用的情况.
		
####static (静态)
	1.静态的成员变量只会在数据共享区中维护一份,而非静态成员变量的数据会在每个对象中维护一份.
	作用:
		1.static修饰成员变量: 如果有数据需要被共享给所有对象使用时,可以用static修饰.
			静态成员变量的访问方式:
				方式1:可以使用对象进行访问.
					格式:对象.变量名
				方式2:可以使用类名进行访问:
					格式:类名.变量名.
			 注意:非静态成员变量只能通过方式1访问.
		2.static修饰方法(静态的成员方法):
			如果一个函数没有直接访问到非静态的成员时,那么久可以使用static修饰了,一般用于工具类型的方法
					不用创建对象,节省内存.
			注意:1.静态函数可以直接访问静态的成员,但不能访问非静态成员. 
				 2.静态函数不能出现this或者super关键字
	静态数据的生命周期:
		静态的成员变量数据是优先于对象存在的.
	静态的成员变量与非静的成员变量的区别:
		1.作用上的区别:
		2.存储位置上的区别:
			1.静态成员变量时存储方法区内存中,而且只会存在一份数据.
			2.非静态的成员变量时在堆内存中,有n个对象就有n分数据.
		3.生命周期的区别:
			1.静态的成员变量数据是随着类的加载而存在,随着类文件的消失而消失.
			2.非静态的成员数据是随着对象的创建而存在,随着对象被垃圾回收器回收而消失.

####main函数:
	public: 公共的.保证jvm任何时候都可以访问到main方法.
	static:静态让jm调用main函数更加方便,不需要通过对象调用...
	void:没有返回值,因为返回的数据是给jvm的,没有意义
	main:函数名. 注意:main并不是关键字,只不过是jvm能识别的一个特殊的函数名而已.
	arguments:参数...,,担心某些程序在启动需要参数.

####单例设计模式:
	保证一个类在内存中只有一个对象.
	步骤:
		1.饿汉单例设计模式:
			1.私有化构造函数.
			2.声明本类的引用类型变量,并且使用该变量指向本类对象.
			3.提供一个公共静态的方法获取本类的对象.
		2.懒汉单例设计模式:
			1.私有化构造函数.
			2.声明本类的引用类型变量,但是不要创建对象.
			3.提供公共静态的方法获取本类的对象,获取之前先判断是否已经创建了本类对象.没有则先创建再返回.
		推荐使用:饿汉,因为懒汉存在线程安全问题,不能保证该类内存中只有一个对象.
		
###继承
	继承通过关键字extends体现.
	格式:
		class 类名1 extends 类名2{
		}
	注意事项::1.父类私有的成员不能被继承.
		 2.父类的构造函数不能被继承.
		 3.创建子类对象时默认会先调用父类的无参构造函数.
####super关键字:
	super代表了父类空间的引用.
	作用:
		1.子父类存在同名的成员时,通过super访问指定访问父类的成员
		2.创建子类对象时,默认会先调用父类无参的构造方法,可以通过super关键字指定调用父类的构造方法.
	注意事项:
		1.如果没有指定父类的构造方法,那么java编译器会在子类的构造方法上线加上super()语句.
		2.super与this关键字不能同时出现在同一个构造函数中,因为两个语句都需要位于第一个语句.
####重写:
	子父类出了同名的函数,称之为方法的重写.
	注意:
		1.方法重写时,方法名与形参列表必须一致.
		2.方法重写时,子类的权限修饰符必须要大于或者等于父类的权限修饰符.
####instanceof关键字
	作用:判断一个对象是否属于指定的类别.
	前提:判断的对象与指定的类别必须要存在继承或者实现的关系.
	格式:
		对象 instanceof 类别
	
		

	