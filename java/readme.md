###java 通过虚拟机实现跨平台(一次编译,到处运行)
	编译成class,通过java虚拟机在操作系统上运行
###jre与jdk
	jre java运行环境.  jre = java虚拟机+核心类库(java虚拟机运行的文件)
	jdk	 java开发工具集	 jdk = jre+java开发工具
	
	java.exe 启动java虚拟机编译并执行指定的class文件
	javac.exe 启动java编译器对指定的java源文件进行编译5
###配置path环境的目的
		控制台可以在任意的路径下找到java开发工具
###main方法:
	程序的主入口,代码是从住方法上开始执行的.
	定义一个类中使用,如果一个类需要独立运行的时候,就需要main方法.
###注释
		单行注释:  //注释内容
		多行注释:  /*注释内容*/
		文档注释:  /***注释内容*/
	文档注释与多行注释的区别:
		多行注释的内容不能用于生成一个开发者文档,而文档注释的内容可以生产一个开发者文档.
	单行注释可以嵌套,多行注释和文档注释不能嵌套.
###使用javadoc工具  javadoc -d 位置 源文件名.java
	1.如果一个类需要使用javadoc工具生成一个软件的开发者文档,那么该类必须使用public修饰.
	2.文档注释注释的内容一般都是位于类或者方法的上面
####常量:	
		整数常量
			二进制用0b开头
			八进制用0开头
			十六进制用0x开头
		小数常量
		布尔常量
		字符常量
		字符串常量
####变量数据类型
	基本数据类型:8种类型
		整数的数据类型:
			byte(字节)   8位(bit)   2*8=256	-128~127
			short(短整型)	16bit
			int(整型)		32bit   
			long(长整型)	64bit
				注意:如果用long类型的数据,数据后需要加L标识
		小数的数据类型:
			float(单精度浮点型)		32bit
			double(双精度浮点型)	64bit
				注意:如果一个小数没有加上任何标识的时候,那么该小数默认是double类型的数据,
					如果需要用float,数据后面需要加f标识
		布尔类型:
			boolean:只有true或者false	1个字节或4个字节
			注意:如果使用boolean声明一个基本类型的变量时,那么该变量占4个字节,如果声明一个数组类型时,那么每个数组的元素占一个字节.
		字符类型:
			char   'a' 单引号是字符.   "a"双引号是字符串
	数据类型转换注意:
		1.凡是byte,short,char数据在运算的时候都会自动转换为int类型的数据再运算.
		2.两个不同数据类型的数据在运算的时候,结果取决于大的数据类型
		3.java编译器在编译的时候并不能确认变量所存储的值,变量存储的值是在运行的时候才在内存中分配空间.
	引用数据类型:
		字符串的数据类型
			String
			注意:字符串属于引用数据类型,不属于基本数据类型
		注意:"=="用于引用类型变量时,比较的是内存地址.
			 如果比较两个字符串的内容是否一致,使用equals方法.
###运算符
####算数运算符
	+	注意:任何类型的数据与字符串使用+连接,那么结果都是字符串类型的数据.
	%  取模,取余数 注意:java中取模运算时,结果的正负号取决于被除数
	++ (自增):  操作数+1 
		前自增(++a): 先自增,后使用.
		后自增(a++):  先使用,后自增.
####逻辑运算符
	&(与)
	|(或)
	^(异或)  两边不一致则为true,一致则为false
	!(非)
	&&(短路与|双与)	
		与&不同点: 使用短路与的时候,如果左边的布尔表达式为false,则不会再运算右边的布尔表达式 .
			在左侧为false的情况下,&&效率要高于&
	||(短路或)	
		与|不同点:	使用短路或的时候,当发现左边的布尔表达式为true时,则不会运算右边的布尔表达式.
####位运算符
	&(与)	6&2=2 转为二进制,进行与运算,得到结果后转为十进制
	|(或)	
	^(异或)
	规律:如果操作数A连续异或同一个操作数两次,那么结果还是操作数A
	应用:对数据进行加密
	~(取反)
####移位运算符
	<<(左移)	左移n位,等于操作数乘以2的n次方.
	>>(右移)	
	>>>(无符号右移)
		与右移的区别:进行右移运算的时候,如果操作数是一个整数,那么左边的空缺位使用0补,
		如果操作数是一个负数,那么左边的空缺位使用1补.而使用无符号右移的均用0补.
####三元运算符
	格式:布尔表达式?值1:值2;
###语句
####if判断语句
	细节:如果符合条件后只有一句代码需要执行,那么可以省略大括号.
####switch选择语句
		格式:
			switch(option){
				case 1:
					break;
				case 2:
					break;
				default: 
					break;
				}
	1.case后面跟的数据必须是一个常量.
	2.switch的停止条件:
		witch语句一旦匹配上了其中的一个case语句,那么就会执行对应的case中的语句代码,
		执行完毕后如果没有遇到break或者结束switch语句的大括号,那么switch语句不会再
		判断,而是按照代码的顺序从上往下执行所有的代码.
	3.都不符合条件,则执行default语句.
####while与do while的区别:
	while 会先判断再执行.
	do while 会先执行再判断,所以不管条件是否满足至少会执行一次
####转义字符 
	特殊字符使用"\"将其转化成字符的本身输出,那么使用"\"的字符 作为转义字符
	常见的转义字符:
		\b 退格键
		\t Tab键盘(为了让一列对齐,一个tab一般等于4个空格)
		\n 换行
		\r 回车(把光标移动到一行的首位置上)
	注意:如果是在windows系统上操作文件的时候需要换行,需要\r\n一起使用的.
		 如果是其他的操作系统上需要换行,仅需要\n即可
####break作用于外层的for循环:
	通过对循环进行标记,然后break 标记.
	实例:
		outer:for(int a=0;a<3;a++){
			inner:for(int b=0;b<2;b++}{
				break outer;}
				}
###函数
####定义函数
	格式:
		修饰符 返回值类型 函数名(形参列表){
			代码}
####函数的重载
	定义:在一个类中出现两个或者两个以上的同名函数,成为函数的重载
	作用:同一个函数名可以出现了不同的函数,以应对不同个数或者不同数据类型的参数.
####变量种类:
	局部变量:如果一个变量时在一个方法的内部生命的,那么该变量就是一个局部变量.
	成员变量:成员变量就是定义在方法之外,类之内的.
####内存种类:
	栈内存特点:栈内存存储的都是局部变量,变量一旦出了自己的作用于,那么马上会从内存中消失,释放内存空间
		
	堆内存特点:堆内存存储的都是对象数据(除8种基本数据类型以外的数据类型),对象一旦被使用完,并不会马上从内存中小时,而是等待垃圾回收期不定时
				把对象回收,这时候该对象才会消失,释放内存.
		对象如果没有变量引用了,那么该对象就是一个垃圾对象.
		凡是以new关键字创建的对象,jvm都会在堆内存中开辟一个新的空间,创建一个新的对象.
	
###数组
	存储同一种数据类型的集合容器.
	特点:
		1.只能存储同一种数组类型的数据,除了object数组.(Object[] arr = new Object[10]};
		2.一旦初始化,长度固定.
		3.数组中的元素与元素之间的内存地址是连续的.
	一维数组定义格式: 
		数据类型[] 变量名 = new 数据类型[长度]
	二维数组定义格式:
		数据类型[][] 变量名 = new 数组类型[长度1][长度2]
	数组中元素与元素之间的内存地址是连续的
	初始化方式:
		动态初始化:
			数据类型 变量名 = new 数据类型[长度]
		静态初始化:
			数据类型[] 变量名 = {元素1,元素2....}
	数组方法:
		需要导入java.util.Arrays
		1.Array.toString(数组名) 数组转字符串
		2.Array.sort(数组名)	(选择排序算法)排序数组
		3.Arrays.binarySearch(数组名.目标值)	(二分法查找)查找数值.如果能找到对应的元素,返回索引值,如果没有找到那么返回一个负数表示.

###collection
	集合的体系:
	--------Collection 单例集合的根接口.
	-------------List: 特点:有序,可重复.
	----------------ArrayList  特点:查询速度快,增删慢. (因为数组中的元素与元素之间的内存地址是连续的)
						底层是维护了一个object数组实现的,默认容量为10,当长度不够是,自动增长0.5倍
	----------------LinkedList  
						底层是使用了链表数据结构实现的.特点:查询速度慢,增删快.
	-------------Set: 特点:无序,不可重复.
	----------------HashSet 
						底层是使用了哈希表来支持的.特点:存取速度快,
	----------------TreeSet 
						如果元素具备自然顺序的特性,那么就按照元素自然顺序地特性进行排序存储.
								
	集合是存储对象数据的集合容器
	集合比数组的优势:
		1.集合可以存储任意类型的对象数据,数组只能存储同一种数组类型的数据.
		2.集合的长度是会发生变化的.数组的长度是固定的.
		
	增加
		add(E e)  添加成功返回true，添加失败返回false.
		addAll(Collection c)  把一个集合的元素添加到另外一个集合中去。
	删除
		clear() 清空
		remove(Object o) 删除元素 
		c1.removeAll(c2) 删除c1集合中的与c2集合的交集元素.
		c1.retainAll(c2) 保留c1集合中的与c2集合的交集元素.
	查看
		size() 集合的元素个数
	判断
		isEmpty() 是否为空
		contains(Object o)  是否包含指定元素,contains方法内部是依赖equals方法来比较的.
		containsAll(Collection<?> c)  是否包含集合中的所有元素
	遍历集合的元素:
		方式一: 
		    toArray() 返回包含此collection中所有元素的Object数组
		方式二:
		 迭代器的作用:用于抓取集合中的元素
			iterator() 返回一个迭代器
		迭代器的方法:
			hasNext() 当前指针是否有指向元素,如果有返回true,否则返回false.
			next()  返回当前指针指向的元素,然后指针向下移动一个单位.如果没有元素则报错
			remove() 移除迭代器返回的最后一个元素,即指针指向的前一个元素.所以必须使用一次next(),才能使用remove()否则报错.
####list特有方法
	List: 有序,可重复.
	list接口下面的集合类才具备索引值.
	增加:
		add(int index,E element)
		addAll(int index,Collection c)
	获取:
		get(int index)
		indexOf(Object o)
		lastIndexOf(object o)
		subList(int fromIndex,int toIndex)   
	修改:
		set(int index, E element)
	迭代:
		listIterator()
		list迭代器特有的方法:
			add(E e)	将指定的元素插入列表
			hasPrevious() 判断是否存在上一个元素.不会移动指针.
			previous() 当前指针先向上移动一个单位,然后再取出当前指针指向的元素.
			add(E e) 把当前有元素插入到当前指针指向的位置上.
			set(E e) 替换迭代器最后一次返回的元素. 
	注意:
		1.在迭代器迭代元素的过程中,不允许使用集合对象改变集合中的元素个数,如果需要,必须使用迭代器方法.
		  如果使用了集合对象就会出现ConcurrentModificationException异常.
####Linkedlist特有方法
	1.方法介绍
		addFirst() 添加到集合的首位置.
		addLast() 添加到集合的末尾处.
		getFirst() 获取首元素的元素
		getLast() 获取末尾的元素
		removeFirst() 删除集合中的手位置元素并返回
		removeLast() 删除集合中的末尾元素并返回
	2.数据结构
		1.栈:先进后出,后进先出
			push() 插入集合的开头处
			pop()	移除并返回集合中的第一个元素
		2.队列:先进先出,后进后出.
			offer() 将元素添加到末尾
			poll() 获取并移除此列表的头
			
####HashSet	
	哈希表的特点:桶式结构
	实现原理:往Hashset添加元素的时候,hashset会先调用元素的hashcode方法得到元素的哈希值
			 然后通过元素的哈希值经过移位等运算,就可以算出该元素在哈希表中的存储位置.
			 分两种情况:
				1.如果算出元素存储的位置目前没有任何元素存储,那么该元素就可以直接存储到该位置上
				2.如果算出元素存储的位置已经存在有其他的元素,那么会调用该元素的equals方法与该位置的元素再比较一次,
				    如果equals返回true,那么该元素与这个位置上的元素就是为重复元素,不允许添加,
					如果返回false,就会运行添加.
	HashCode()默认情况下表示的是内存地址,String类已经重写了Object的hashCode方法.

####treeSet
	1.treeSet添加自定义元素:
		1.如果元素自身具备了自然顺序的特性,那么就按照元素自然顺序地特性进行排序存储.
		2.如果不具备自然顺序地特性,那么该元素所属的类就必须要实现Comparable接口,
			把元素的比较规则定义在CompareTo()方法上
		3.如果比较元素的时候,compareTo方法返回的是,那么该元素就被视为重复元素,不允许添加.(TreeSet与HasCode和equals方法是没有任何关系的)
		4.往TreeSet添加元素的时候,如果元素本身没有具备自然顺序地特性,那元素所属的类也没有实现Comparable接口,那么必须要在创建TreeSet中传入一个比较器.
			如何自定义定义比较器:自定义一个个类实现Comparator接口即可,把元素与元素之间的比较规则定义在compare方法中即可.
				格式:
					class 类名 implements Comparator{
						public int compare(Object o1, Object o2) {
						}
					}
		5.如果同时存在Comparable接口和比较器,会优先使用比较器
		推荐使用比较器.
	2.Tree是可以对字符串进行排序的,因为字符串已经实现了Comparable接口.
		字符串比较规则:
			情况一: 可以找到对应不同的字符,比较的就是对应位置上不同的字符.
			情况二: 找不到对应不同的字符,比较的就是字符串的长度.

###泛型			
	格式:
		ArrayList<String> list = new ArrayList<String>();
		
	好处:
		1.将运行时的异常提前至了编译时.
		2.避免了无谓的强制类型转换.
	
	在泛型中不能使用数据类型,如果需要使用基本数据类型,那么就使用基本数据类型对应的包装类型.
	byte---> Byte
	short-->Short
	int---->Integer
	char--->Character
	
####自定义泛型
	一个数据类型的占位符或者是一个数据类型的变量.
	
	注意事项:
		自定义泛型一般习惯使用一个大写字母表示.
		
#####方法上自定义泛型:
	定义格式:
		修饰符  <声明自定义的泛型>返回值类型 函数名(使用自定义泛型..){
		
			}
	注意事项:
		1.在方法上自定义泛型,这个自定义泛型的具体数据行嘞是在调用该方法的时候传入实参时确定具体的数据类型的.

#####类泛型
	定义格式:
		class 类名<声明自定义泛型>{
		}
	注意事项:
		1.在类上自定义泛型的具体数据类型是在使用该类的时候创建对象时候确定的.
		2.如果使用该类创建对象的时候没有指定泛型的具体数据类型,那么默认为Object类型
		3.在类上自定义泛型不能用作于静态的方法,如果静态的方法需要使用自定义泛型,那么需要在方法上声明使用.

####泛型接口
	定义格式:
		interface 接口名<声明自定义泛型>{
		}
	如果要延长接口自定义泛型的具体数据类型,那么格式如下:
		public class Demo4<T> implements Dao<T>{
		
		}
	注意事项:
		1. 接口上自定义的泛型的具体数据类型是在实现一个接口的时候指定的.
		2. 

####泛型的上下限	
	泛型的通配符: ?
	? super Integer: 只能存储Integer或者Integer父类元素. 泛型的下限
	? extends Number: 只能存储Number或者Number类型的子类数据	泛型的上限
		
	
	
##面向对象
####面向对象的三大特征:封装,继承,多态
####自定义类创建对象的三步骤:
		1.自定义类:
				格式:
					class 类名{
						}
		2.通过自定义类创建对象 .
				格式:
					类名 变量名 = new 类名()
		3.访问(设置)对象的属性或者调用对象的功能.
			访问对象属性的格式:
				对象.属性名.
			设置对象的属性:
				对象.属性名 = 数据
###封装
	步骤:
	1.使用private属性
	2.提供一个公共的方法设置或者获取私有的成员属性.
			命名规范:
				set属性名();
				get属性名();
	规范:在现实开发中一般实体类的所有成员属性(成员变量)都要封装.
	实体类:用于描述一类事物的
	工具类(array数组的工具类)
	封装的好处:
		1.提高数据的安全性.
		2.操作简单.
		3.隐藏了实现
	
#####权限修饰符:控制变量的可见范围.
		public:公共的.均可访问.
		protected:受保护的,可以在同一个包的本类和子类访问,不能在不同包访问.
		default(缺省):可以在同一个包的本类访问,不能子类和包访问.
		private:私有的.只能在本类中直接访问,
	注意:
		1.在不同包下面只有public和protected可以访问,而且protected必须是在继承关系下才能访问.
	
####成员变量与局部变量的区别:
	class Person{
		String name;//成员变量
		public void eat(){
			String name;//局部变量
		}
	}
	1.定义位置的区别:
		成员变量:定义在方法之外,类之内.
		局部变量:定义在方法之内.
	2.作用上的区别:
		成员变量:用于描述一类事物的公共属性.
		局部变量:提供一各变量给方法内部使用而已/
	3.生命周期的区别:
		1.成员变量:随着对象的创建而存在,随着对象的消失而消失.
		2.局部变量:在调用对应的方法时执行到了创建该变量的语句时存在,局部变量一旦出了自己的作用域,那么马上从内存中消失.
	4.初始值的区别:
		1.成员变量是有默认的初始值.
			例如:
				String = null
				int = 0
				char = ' '
		2.局部变量没有默认的初始值,必须要先初始化才能使用.

####匿名对象:没有引用类型变量指向的对象
	格式:
		new 类型()
	注意事项:
		1.一般不会给匿名对象赋予属性值,因为永远无法获取到.
		2.两个匿名对象永远都不可能是同一个对象.
	应用场景:
		1.如果一个对象需要调用一个方法,而调用完这个方法之后,不再使用该对象.
		2.作为实参调用一个参数
		
####构造函数:
	作用:给对应的对象进行初始化.
	格式:
		修饰符	函数名(形参函数){
			函数体...
		}
	构造函数要注意的细节:
		1.没有返回值类型.
		2.函数名必须要与类名一致.
		3.构造函数会在创建对应的对象时,jvm会主动调用到对应的构造函数
		4.如果一个类中如果没有显式的协商一个构造方法时,java编译器会为该类添加一个无参的构造函数.
	构造代码块:
		作用:给对象进行统一的初始化.
		格式:
			{
				构造代码块
			}
		注意:构造代码块的大括号必须位于成员位置上.
		类别:
			1.构造代码块.
			2.局部代码块.	大括号位于方法之内.作用:缩短局部变量的生命周期,节省内存
	注意事项:
		1.java编译器编译一个java源文件的时候,会把成员变量的声明语句提前至一个类的最前端.
		2.成员变量的初始化工作其实都在构造函数中执行的.
		3.一旦经过javav编译器编译后,那么构造代码块的代码块就会被移动构造函数中执行,构造函数中的代码是最后执行的.
		4.成员变量的显示初始化与构造代码块的代码是按当前顺序执行的

####this
	一个方法要运行的时候,jvm会在栈内存中开辟一片属于这个方法的空间,在空间中运行.
	解决问题: 存在同名的成员变量与局部变量时,在方法的内部访问的是局部变量(java采取"就近原则"机制访问的)
	作用:
		1.如果存在同名成员变量或局部变量.
		2.在一个构造函数中可以调用另外一个构造函数初始化对象. this();
	注意事项:
		1.this关键字调用其他的构造函数时,this关键字必须要位于构造函数中的第一个语句.
		2.this关键字在构造函数中不能出现相互调用的情况.
		
####static (静态)
	1.静态的成员变量只会在数据共享区中维护一份,而非静态成员变量的数据会在每个对象中维护一份.
	作用:
		1.static修饰成员变量: 如果有数据需要被共享给所有对象使用时,可以用static修饰.
			静态成员变量的访问方式:
				方式1:可以使用对象进行访问.
					格式:对象.变量名
				方式2:可以使用类名进行访问:
					格式:类名.变量名.
			 注意:非静态成员变量只能通过方式1访问.
		2.static修饰方法(静态的成员方法):
			如果一个函数没有直接访问到非静态的成员时,那么久可以使用static修饰了,一般用于工具类型的方法
					不用创建对象,节省内存.
			注意:1.静态函数可以直接访问静态的成员,但不能访问非静态成员. 
				 2.静态函数不能出现this或者super关键字
	静态数据的生命周期:
		静态的成员变量数据是优先于对象存在的.
	静态的成员变量与非静的成员变量的区别:
		1.作用上的区别:
		2.存储位置上的区别:
			1.静态成员变量时存储方法区内存中,而且只会存在一份数据.
			2.非静态的成员变量时在堆内存中,有n个对象就有n分数据.
		3.生命周期的区别:
			1.静态的成员变量数据是随着类的加载而存在,随着类文件的消失而消失.
			2.非静态的成员数据是随着对象的创建而存在,随着对象被垃圾回收器回收而消失.

####main函数:
	public: 公共的.保证jvm任何时候都可以访问到main方法.
	static:静态让jm调用main函数更加方便,不需要通过对象调用...
	void:没有返回值,因为返回的数据是给jvm的,没有意义
	main:函数名. 注意:main并不是关键字,只不过是jvm能识别的一个特殊的函数名而已.
	arguments:参数...,,担心某些程序在启动需要参数.

###设计模式
####单例设计模式:
	保证一个类在内存中只有一个对象.
	步骤:
		1.饿汉单例设计模式:
			1.私有化构造函数.
			2.声明本类的引用类型变量,并且使用该变量指向本类对象.
			3.提供一个公共静态的方法获取本类的对象.
		2.懒汉单例设计模式:
			1.私有化构造函数.
			2.声明本类的引用类型变量,但是不要创建对象.
			3.提供公共静态的方法获取本类的对象,获取之前先判断是否已经创建了本类对象.没有则先创建再返回.
		推荐使用:饿汉,因为懒汉存在线程安全问题,不能保证该类内存中只有一个对象.

####模板模式:
	解决某类事情的步骤有些事固定的,有些事发生变化的,那么为这类事情提供一类模板代码,从而提高效率.
	步骤:
		1.先写出解决该类事情其中的一件的解决方案.
		2.分析代码,把会发生变化的代码抽取出来独立成一个方法.把该方法描述成一个抽象的方法
		3.使用final修饰模板方法,防止别人重写模板方法.
		
###继承
	继承通过关键字extends体现.
	格式:
		class 类名1 extends 类名2{
		}
	注意事项::1.父类私有的成员不能被继承.
		 2.父类的构造函数不能被继承.
		 3.创建子类对象时默认会先调用父类的无参构造函数.
	一个类最多只能有一个字节的父类
####super关键字:
	super代表了父类空间的引用.
	作用:
		1.子父类存在同名的成员时,通过super访问指定访问父类的成员
		2.创建子类对象时,默认会先调用父类无参的构造方法,可以通过super关键字指定调用父类的构造方法.
	注意事项:
		1.如果没有指定父类的构造方法,那么java编译器会在子类的构造方法上线加上super()语句.
		2.super与this关键字不能同时出现在同一个构造函数中,因为两个语句都需要位于第一个语句.
####重写:
	子父类出了同名的函数,称之为方法的重写.
	注意:
		1.方法重写时,方法名与形参列表必须一致.
		2.方法重写时,子类的权限修饰符必须要大于或者等于父类的权限修饰符.
####instanceof关键字
	作用:判断一个对象是否属于指定的类别.
	前提:判断的对象与指定的类别必须要存在继承或者实现的关系.
	格式:
		对象 instanceof 类别

####final(最终)
	每个方法要运行的时候,jvm都会为该方法开辟一片内存空间是属于这个方法的.
	用法:
		1.final修饰一个基本类型的变量时,该变量不能重新赋值.
		2.final修饰一个引用类型变量时,该变量不能重新指向新的对象.
		3.final修饰一个函数时,该函数不能被重写.
		4.final修饰一个类时,该类不能被继承
	常量的修饰符一般为:public static final
	常量的命名规范:全部字母大写
####抽象类
	应用场景:描述一类事物的时候,发现事物存在某种行为,但是这种行为目前不具体的,我们可以抽取这种行为的生命,
	但是不去实现.
	好处:强制要求子类移动要实现指定的方法.
	注意细节:
		1.如果一个函数没有方法体,那么该函数必须要使用abstract修饰,把该函数修饰成抽象的函数. 
		2.如果一个类出现了抽象的函数,那么该类也必须使用abstract修饰.
		3.如果一个非抽象类继承了抽象类,那么必须要把抽象类的所有抽象方法全部实现.
		4.抽象类可以存在非抽象方法.
		5.抽象类可以不存在抽象方法的.
		6.抽象类是不能创建对象的.
		7.抽象类是存在构造函数的,其构造函数时提供给子类创建对象的时候初始化父类的属性的.
	abstract不能与以下关键字共同修饰一个方法:
		1.private
		2.abstract
###接口
	接口的作用:
		1.拓展功能.
		2.定义约束规范.
		3.程序的解耦.(低耦合
	格式:
	interface 接口名{
		}
	注意事项:
		1.接口是一个特殊的类.
		2.接口的成员变量默认的修饰符为:public static final.也就是说接口中的成员变量都是常量.
		3.接口中的方法都是抽象的方法.默认的修饰符为:public abstract
		4.接口不能创建对象.
		5.接口是没有构造方法的.
		6.接口是给类去实现使用的.非抽象类实现 一个接口的时候,必须要把接口中所有方法全部实现.
	实现接口的格式:
		class 类名 implements 接口名{
			}
			
####类与接口之间的关系:
	实现关系.
	注意:
		1.非抽象类实现一个接口时,必须把接口中所有方法全部实现
		2.接口类实现一个接口时,可以实现也可以不实现接口中的方法.
		3.一个类可以实现多个接口
		4.java类可以单继承,多实现.接口可以多继承		
####接口与接口之间的关系:
	继承关系:
	注意:
		1.一个继承是可以继承多个接口的.

###多态:
	一个对象具有多种形态.(父类的引用类型变量指向了子类对象
						或者是接口类型的引用类型变量指向了接口实现类的对象)
	多态的前提:必须存在继承或者实现关系.
	格式:
		动物(父类) a = new 狗(子类)
	注意细节:
		1.多态情况下,子父类存在同命的成员变量时,访问的是父类的成员变量.
		2.多态情况下,子父类存在非静态的成员函数时,访问的是子类的成员函数.
		3.多态情况下,子父类存在静态的成员函数时,访问的是父类的成员函数.
		4.多态情况下,不能访问子类特有的成员.
	总结:
		多态情况下,子父类存在同命的成员时,范文的都是父类的成员,只有在同名非静态函数时才是访问子类的.
	原理:
		编译器左边,运行不一定看右边.
		编译器左边:java编译器在编译的时候,会检查引用类型变量所属的类是否具备指定的成员,如果不具备马上编译报错.
	多态的应用:
		1.多态用于形参类型的时候,可以接受更多类型的数据.
		2.多态用于返回值类型的时候,可以返回更多类型的数据.
	多态的好处:
		1.提高代码的拓展性.
	如果需要访问子类特有的成员,需要进行类型强制转换.
	基本数据类型的转换:
		小数据类型-->大数据类型  自动类型转换
		大数据类型-->小数据类型  强制类型转换		小数据类型 变量名 =(小数据类型)大数据类型;

####实现关系下的多态
	格式:
		接口 变量 = new 接口实现类的对象.
###内部类
	一个类定义在另外一个类的内部,那么该类成为内部类.
	内部类的class文件名: 外部类$内部类.  好处:便于区分该class文件是属于哪个外部类的.
	内部类的应用场景:
		我们在描述A事物的时候,发现描述的A事物内部还存在另外一个比较复杂的事物B的时候,而且这个比较复杂事物B还需要访问A事物的属性等数据,那么这时候我们就可以使用内部类描述B事物
	内部类的好处:
		内部类可以直接访问外部类的所有成员.
	注意事项:
		1.如果外部类与内部类存在同名的成员变量时,在内部类默认访问内部类的成员变量.
			可以通过"外部类.this.成员变量名" 指定访问外部类的成员.
		2.私有的成员内部类只能在外部类提供一个方法创建内部类的对象进行访问,不能再其他类创建对象访问.
		3.成员内部类一旦出现了静态的成员,那么该类也必须使用static修饰.
			原因:静态的成员数据是不需要对象存在才能访问. 
	内部类的类别:
		1.成员内部类:
			成员内部类的访问方式:
				1.在外部类提供一个方法创建内部类的对象进行访问.
				2.在其他类直接创建内部类的对象.格式:外部类.内部类 变量名 =new 外部类().new 内部类()
			注意:如果是一个静态内部类,那么创建格式:
				外部类.内部类 变量名 = new 外部类.内部类()
		2.局部内部类:
			在一个类的方法内部定义另外一个类,那么另外一个类就成为局部内部类
			注意:
				1.如果局部内部类访问一个局部变量,必须要要final修饰 
		3.匿名内部类:
			没有类名的类就称作为匿名内部类.
			好处:简化书写
			使用前提:必须存在继承或者实现关系才能使用.
			匿名内部类一般用于实参.
###异常
	异常体系:
	---|Throwable	所有异常或者错误类的超类
	-----|Error		错误	错误一般是用于jvm或者是硬件引发的问题,所以一般不会通过代码去处理错误.
	-----|Excepttion	异常	是需要代码去处理的
	区分错误与异常:
		如果错误出现了不正常的信息,如果不正常的信息的类名是以Error结尾,
		如果以Exception结尾的,那么肯定是一个异常.
	Throwable常用的方法:
		toString() 返回当前异常对象的完整类名(包名+类名).
		getMessage()	返回创建Throwable传入的字符串信息.
		printStackTrace()	打印异常的栈信息
	异常的处理:
		方式一:捕获处理
			格式:
				try{
				}catch(捕获的异常类型 变量名){
				}
		细节:
			1.一个try后面是可以跟多个catch块的
			2.捕获的异常类型必须从小到大进行捕获,否则编译报错.
		方式二:抛出处理
			注意:
				1.如果一个方法的内部抛出一个编译时异常对象,那么必须要在方法上声明抛出.
				2.如果调用一个声明抛出编译时异常的方法,那么调用者必须要处理异常.
				3.一个方法遇到throw关键字,该方法会停止执行.
	
	throw与throws两个关键字:
		1.throw是用于方法内部的,throws是用于方法声明上的.
		2.throw是用于方法内部抛出一个异常对象的,throws是用于在方法声明上声明抛出异常类型的.
		3.throw后面只能有一个异常对象,throws后面一次可以声明抛出多种类型的异常
	自定义异常类步骤:1.自定义一个类继承Exception即可
####finally块	
		前提是必须要存在try块才能使用.
		finaaly块的代码在任何情况下都会执行的,除了jvm退出的情况.
		finally非常适合做资源释放的工作.
###包
	java中的包相当于windows文件夹
	作用:
		1.解决类名重复产生冲突的问题.
		2.便于版本的发布. 
	定义包的格式:
		package 包名;
	注意:
		1.包名命名规范:全部小写.
		2.package语句必须位于java文件中的第一语句.
		3.如果一个类加上了包语句,那么该类的完整类名就是:包名.类名
####jar包	
	需要使用到jdk的开发工具(jar.exe). 
	使用格式：
		jar cvf jar文件的名字  class文件或者是文件夹 
	打jar包要注意的事项：
		1. 一个程序打完了jar之后 必须要在清单文件上指定入口类： 格式 Main-Class: 包名.类名
		2. jar包双击运行仅对于图形化界面的程序起作用，对控制台的程序不起作用。
	jar文件的作用：
		1. 方便用户快速运行一个项目。
		2. 提供工具类以jar包的形式给别人使用。 
	如果使用jar包里面的类必须要先设置classpath路径。
	jre = jvm+ 核心类库

###object类
####常用方法:
	toString();
		返回该对象的字符串表示. 通过查看源代码得知，直接输出一个对象 的时候，实际上在println方法内部会调用这个 调用的toString方法，把toString方法返回的内容输出。
		当toString方法无法满足子类的需求，那么这时候我们就应该对Object类的toString进行重写。
	equals(Object obj)   :
		用于比较两个对象的内存地址，判断两个对象是否为同一个对象。
	hashCode();
		返回该对象的哈希码值(大家可以把哈希码就 理解成是对象的内存地址.
		

##字符串
	注意:字符串的内容不适宜频繁修改,因为一旦修改马上就会创建一个新的对象.
		如果需要频繁修改字符串的内容,建议使用字符串缓冲类(StringBuffer)
		
###Stringbuffer(存储字符的容器)
	StringBuffer默认的初始容量为16,如果字符数组的长度不够使用时,自动增长1倍.
####StringBuilder 与StringBuffer的相同与不同:
	建议使用StringBuilder.除非遇到线程问题.
	相同点:
		1.两个类都是字符串缓冲类.
		2.两个类的方法都是一致的.
	不同点:
		1.StringBuffer是线程安全的,操作效率低.StringBuilder是线程非安全的.操作效率高.
		2.StringBuffer是jdk1.0出现的,StringBuilder是jdk1.5出现的.
	
####Stringbuffer基本方法
	append() 添加
	insert(int offset,String str) 插入
	capacity() 返回当前容量
	charAt(int index) 返回指定索引处的char值
	delete(int start, int end) 删除序列的子字符串中的字符
	deleteCharAt(int index) 移除指定位置的char
	indexOf(String str) 返回指定字符串的索引.
	replace() 替换
	reverse() 反转
	length() 返回长度

		
###字符串类
	1.String str = "hello" 创建字符串的时候,jvm会先检查方法池中的字符串常量池中是否存在该字符串的对象,如果已经存在,那么就不再创建,直接返回该字符串在字符串常量池中内存地址.
		如果字符串不存在字符串常量池中,就会在字符串常量池中先创建该字符串对象,然后再返回.
	2.new String("hello") 如果在字符串常量池中创建字符串对象,然后还会到堆内存中再创建一份字符串对象,然后返回堆内存中字符串对象的内存地址.
	
####获取方法
	length() 获取字符串你的长度
	charAT(int index) 获取特定位置的字符
	indexOf(String str) 获取特定字符的位置,找不到返回-1
	lastIndexOf(int ch) 获取最后出现特定字符的位置,找不到返回-1
####判断方法
	endsWith(String str) 是否以指定字符结束
	isEmpty() 是否为空
	contaubs() 是否包含指定序列
	equal() 是否相等
	equalsIgnoreCase() 忽略大小写,是否相等
####转换方法
	toCharArray() 将字符串转换为字符数组.
	getBytes() 转换为字节数组
####其他方法
	String replace(oldChar,newChar)替换
	split(String regex)切割
	substring(beginIndex,endIndex)截取
	toUpperCase() 转大写
	toLowercase() 转小写
	trim() 去除空格

##类
###System类(系统类 主要用于获取系统的属性数据)
	currentTimeMillis() 获取当前系统时间
	arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 
          从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。
	exit() 退出jvm 如果参数是0表示正常退出,非0表示异常退出
	gc() 建议jvm赶快启动垃圾回收器回收垃圾
		finalize() 如果一个对象被垃圾回收器回收的时候,会先调用对象的finalize()方法.
	gettenv(String name) 根据环境变量的名字获取环境变量
	getPeoperties() 返回系统的所有属性
	
###runtime类(代表应用程序运行的环境）
	getRuntime() 返回当前程序的运行环境对象(用于创建实例对象).
	exec(String command) 根据指定的路径执行对应的可执行文件.
	freeMemory() 返回jvm空闲的内存,以字节为单位.
	maxMemory() 返回jvm试图使用的最大内存量.
	totalMemory() 返回jvm中的内存总量
	
###Random类
	nextInt(int x) 生成一个从0到x之间的值

##线程
####好处:
	1.解决了一个进程如何同时执行多个任务的问题.
	2.提高资源的利用率
	
####弊端:
	1.增加cpu的负担.
	2.降低了一个进程中线程的执行概率.
	3.引发了线程安全问题.
	4.出现了死锁现象.
	
####关于jvm
	运行任何一个java程序,jvm在运行的时候都会创建一个main线程执行main方法中所有代码 .
	一个java程序至少有2个线程,一个是主线程负责main方法代码的执行,一个是垃圾回收机制
	
####创建线程的方式
	方式一:
		1.自定义一个类继承Thread类,重写Thread的run方法
		重写run方法的目的:
			把自定义线程的任务代码写在run方法中.
		2.创建Thread的子类对象,并且调用start方法开启线程.
		
	方式二:
		1.自定义一个类实现Runable接口.
		2.实现Runnable接口的run方法,把自定义线程的任务定义在 run方法上.
		3.创建Runnable实现类对象.
		4.创建Thread类对象,并且把Runnable实现类的对象作为实参传递.
		5.调用Thread对象的start方法开启一个线程.
	  
	  注意:
		 1.Runnable实现类的对象并不是一个线程对象,只不过是显示了Runnable接口的对象而已.
		   只有Thread或者Thread的子类才是线程对象.
		 2.Runnable实现类的对象的run方法作为了线程的任务代码去执行.
	  推荐使用:第二种.实现Runnable接口的run方法
		原因:因为java单继承,多实现的.
		
####线程常用方法
	Thread(String name)  初始化线程的名字
	getName()	获取线程的名字
	setName(string name) 设置线程对象名
	sleep() 线程睡眠指定的毫秒数
		Thread类的run方法没有抛出异常类型,所以子类不能抛出异常类型.
	currentThread() 返回当前线程对象,该方法是一个静态的方法
	getPriority()	返回当前线程对象的优先级,默认优先级为5
	setProiorty(int x) 设置线程的优先级.范围是1-10

####线程安全问题
	出现线程安全问题的原因:
		1.存在两个或者两个以上的线程对象,而且线程之间共享着一个资源
		2.有多个语句操作了共享资源
	
	解决方案:线程同步机制
		方式一:同步代码块
			格式:
				synchronized(锁对象){
					需要被同步的代码.
				}
			注意事项:
				1.任意的一个对象都可以作为锁对象.
				2.凡是对象内部都维护一个状态的,java同步机制就是使用了对象中的状态作为了锁的标识.
				3.在同步代码块中调用了sleep方法并不是释放锁对象的.
				4.多线程操作的锁对象必须是唯一共享的,否则无效.
				5.如果不存在线程安全问题使用同步代码块,会降低效率.
		方式二:同步函数:使用synchronized修饰一个函数.
			注意事项:
				1.如果是一个非静态的同步函数的锁 对象是this对象,如果是静态的同步函数的锁对象是当前函数所属的类的字节码文件(class对象).
				2.同步函数的锁对象是固定的,不能由你来指定的.
	推荐:同步代码块
		1.同步代码块的锁带向可以由我们随意指定,方便控制.同步函数的锁对象是固定的,不能由我们指定.
		2.同步代码块可以很方便控制被同步代码的范围,同步函数必须是整个函数的所有代码都被同步了.
####死锁
	java同步机制解决了线程安全问题,但是也同时引发死锁现象.
	出现的原因:
		1.存在两个或者两个以上的线程.
		2.存在两个或者两个以上的共享资源.
	解决方案:

####线程通讯
	一个线程完成了自己的任务时,要通知另外一个线程去完成另外一个任务.
	生产者与消费者
	wait(): 等待 如果线程执行了wait方法,那么该线程会进入等待的状态,等待状态下的线程必须要被其他线程调用notify方法才能唤醒.
	notify(): 唤醒等待的线程.
		注意事项:
			1.wait方法与notify方法是属于object对象的.
			2.wait方法与notify方法必须要在同步代码块或者同步函数中才能使用.
			3.必须要由锁对象调用.
####守护线程(后台线程)
    守护线程如果关闭,则其他线程都会关闭.
	线程对象.isDaemon() 判断线程是否为守护线程.
	线程对象.setDamon(boolean)设置线程是否为守护线程,true为守护线程.
####join方法: 
		一个线程如果执行join语句,那么就有新的线程加入,执行该语句的线程必须要让步给新加入的线程先完成任务,然后才能继续执行.
	